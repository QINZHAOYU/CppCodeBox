# 关于 C/C++ 的一些技术细节

本篇收集整理 `C/C++` 编程中的一些技术细节，方便日后查看以及防止同样的错误再犯。   

+ [语法细节](#语法细节)
+ [编译细节](#编译细节)
+ [接口设计、导出与链接细节](#接口相关细节)

---------------------------------------------------------------------------------

## 语法细节

---------------------------------------------------------------------------------

## 编译细节

1. c++ 依赖库区分 `Release` 和 `Debug` 版本（如果库中使用了 STL）:

编译 `Release` 版本程序需要依赖 `Release` 版本依赖库；`Debug` 编译同理。

2. 命令行设置cmake编译选项 `option(RUN_TEST)`:

    >> cmake -DRUN_TEST=off ..



---------------------------------------------------------------------------------

## 接口相关细节

+ [设计接口](#接口设计)
+ [导出动态库](#导出动态库)
+ [链接动态库](#链接动态库)

---------------------------------------------------------------------------------

### 接口设计

### 导出动态库

动态链接库的使用有两种方式，一种是显式调用，一种是隐式调用：  

1. 显式调用：使用LoadLibrary载入动态链接库、使用GetProcAddress获取某函数地址。
2. 隐式调用：可以使用#pragma comment(lib, “XX.lib”)；也可直接将XX.lib加入工程中。
 
**DLL的编写**

编写dll时，有个重要的问题需要解决，那就是函数重命名——Name-Mangling。解决方式有两种，  
1. 在代码里采用extent ”c” _declspec(dllexport)、
   #pragma comment(linker, "/export:[Exports Name]=[Mangling Name]")。
2. 采用def文件。

*为什么有 extern “C”？*

因为C和C++的重命名规则是不一样的。这种重命名称为“Name-Mangling”（名字修饰或标识符重命名）。

据说，C++ 标准并没有规定Name-Mangling的方案，所以不同编译器使用的是不同的。  
例如：Borland C++ 跟 Mircrosoft C++就不同，而且可能不同版本的编译器 用的规则也是不同的。这样的话，  
不同编译器编译出来的目标文件.obj 是不通用的，因为同一个函数，在obj文件中就会有不同的名字。  
如果 DLL 里的函数重命名规则跟 DLL 的使用者采用的重命名规则不一致，那就会找不到这个函数。

C 标准规定了 C语言 Name-Mangling 的规范。这样就使得，任何一个支持C语言的编译器，它编译出来的 obj文件可以共享，链接成可执行文件。这是一种标准，如果DLL跟其使用者都采用这种约定，那么就可以解决函数重命名规则不一致导致的错误。

影响符号名的除了C++和C的区别、编译器的区别之外，还要考虑调用约定导致的Name Mangling。如extern “c” __stdcall的调用方式就会在原来函数名上加上写表示参数的符号，而extern “c” __cdecl则不会附加额外的符号。

dll中的函数在被调用时是以函数名或函数编号的方式被索引的。这就意味着采用某编译器的C++的Name-Mangling方式产生的dll文件可能不通用。因为它们的函数名重命名方式不同。为了使得dll可以通用些，很多时候都要使用C的Name-Mangling方式，即是对每一个导出函数声明为extern “C”，而且采用_stdcall调用约定，接着还需要对导出函数进行重命名，以便导出不加修饰的函数名。

注意到extern “C”的作用是为了解决函数符号名的问题，这对于动态链接库的制造者和动态链接库的使用者都需要遵守的规则。

动态链接库的显式装入就是通过GetProcAddress函数，依据动态链接库句柄和函数名，获取函数地址。因为GetProcAddress仅是操作系统相关，可能会操作各种各样的编译器产生的dll，它的参数里的函数名是原原本本的函数名，没有任何修饰，所以一般情况下需要确保dll’里的函数名是原始的函数名。分两步：一，如果导出函数使用了extern”C” _cdecl，那么就不需要再重命名了，这个时候dll里的名字就是原始名字；如果使用了extern”C” _stdcall，这时候dll中的函数名被修饰了，就需要重命名。二、重命名的方式有两种，要么使用*.def文件，在文件外修正，要么使用#pragma，在代码里给函数别名。

（2）_declspec(dllexport)和_declspec(dllimport)的作用
       _declspec还有另外的用途，这里只讨论跟dll相关的使用。正如括号里的关键字一样，导出和导入。_declspec(dllexport)用在dll上，用于说明这是导出的函数。而_declspec(dllimport)用在调用dll的程序中，用于说明这是从dll中导入的函数。

       因为dll中必须说明函数要用于导出，所以_declspec(dllexport)很有必要。但是可以换一种方式，可以使用def文件来说明哪些函数用于导出，同时def文件里边还有函数的编号。

而使用_declspec(dllimport)却不是必须的，但是建议这么做。因为如果不用_declspec(dllimport)来说明该函数是从dll导入的，那么编译器就不知道这个函数到底在哪里，生成的exe里会有一个call XX的指令，这个XX是一个常数地址，XX地址处是一个jmp dword ptr[XXXX]的指令，跳转到该函数的函数体处，显然这样就无缘无故多了一次中间的跳转。如果使用了_declspec(dllimport)来说明，那么就直接产生call dword ptr[XXX]，这样就不会有多余的跳转了。（参考《加密与解密》第三版279页）

（3）__stdcall带来的影响
       这是一种函数的调用方式。默认情况下VC使用的是__cdecl的函数调用方式，如果产生的dll只会给C/C++程序使用，那么就没必要定义为__stdcall调用方式，如果要给Win32汇编使用（或者其他的__stdcall调用方式的程序），那么就可以使用__stdcall。这个可能不是很重要，因为可以自己在调用函数的时候设置函数调用的规则。像VC就可以设置函数的调用方式，所以可以方便的使用win32汇编产生的dll。不过__stdcall这调用约定会Name-Mangling，所以我觉得用VC默认的调用约定简便些。但是，如果既要__stdcall调用约定，又要函数名不给修饰，那可以使用*.def文件，或者在代码里#pragma的方式给函数提供别名（这种方式需要知道修饰后的函数名是什么）。

 

举例：

 

·extern “C” __declspec(dllexport) bool  __stdcall cswuyg();

·extern “C”__declspec(dllimport) bool __stdcall cswuyg();

 

·#pragma comment(linker, "/export:cswuyg=_cswuyg@0")

 

（4）*.def文件的用途
指定导出函数，并告知编译器不要以修饰后的函数名作为导出函数名，而以指定的函数名导出函数（比如有函数func，让编译器处理后函数名仍为func）。这样，就可以避免由于microsoft VC++编译器的独特处理方式而引起的链接错误。

也就是说，使用了def文件，那就不需要extern “C”了，也可以不需要__declspec(dllexport)了（不过，dll的制造者除了提供dll之外，还要提供头文件，需要在头文件里加上这extern”C”和调用约定，因为使用者需要跟制造者遵守同样的规则，除非使用者和制造者使用的是同样的编译器并对调用约定无特殊要求）。

举例def文件格式：

LIBRARY  XX(dll名称这个并不是必须的，但必须确保跟生成的dll名称一样)

EXPORTS

[函数名] @ [函数序号]

 

编写好之后加入到VC的项目中，就可以了。

       另外，要注意的是，如果要使用__stdcall，那么就必须在代码里使用上__stdcall，因为*.def文件只负责修改函数名称，不负责调用约定。

也就是说，def文件只管函数名，不管函数平衡堆栈的方式。

 

如果把*.def文件加入到工程之后，链接的时候并没有自动把它加进去。那么可以这样做：

手动的在link添加：

1）工程的propertiesàConfiguration PropertiesàLinkeràCommand Lineà在“Additional options”里加上：/def:[完整文件名].def

2）工程的propertiesàConfiguration PropertiesàLinkeràInputàModule Definition File里加上[完整文件名].def

 

注意到：即便是使用C的名称修饰方式，最终产生的函数名称也可能是会被修饰的。例如，在VC下，_stdcall的调用方式，就会对函数名称进行修饰，前面加‘_’，后面加上参数相关的其他东西。所以使用*.def文件对函数进行命名很有用，很重要。

 2011-8-14补充
编写dll可以使用.def文件对导出的函数名进行命名。

 

1、动态装入dll，重命名（*.def）的必要性？
因为导出的函数尽可能使用__stdcall的调用方式。而__stdcall的调用方式，无论是C的Name Mangling，还是C++的Name Mangling都会对函数名进行修饰。所以，采用__stdcall调用方式之后，必须使用*.def文件对函数名重命名，不然就不能使用GetProcAddress()通过函数名获取函数指针。

 

2、隐式调用时，头文件要注意的地方？
因为使用静态装入，需要有头文件声明这个要被使用的dll中的函数，如果声明中指定了__stdcall或者extern “C”，那么在调用这个函数的时候，编译器就通过Name Mangling之后的函数名去.lib中找这个函数，*.def中的内容是对*.lib里函数的名称不产生作用，*.def文件里的函数重命名只对dll有用。这就有lib 跟dll里函数名不一致的问题了，但并不会产生影响，DLL的制造者跟使用者采用的是一致函数声明。

 

3、所以到底要不要使用__stdcall 呢？
我看到一些代码里是没有使用__stdcall的。如果不使用__stdcall，而使用默认的调用约定_cdecl，并且有extern ”C”。那么VC是不会任何修饰的。这样子生成的dll里的函数名就是原来的函数名。也就可以不使用.def文件了。

也有一些要求必须使用__stdcall，例如com相关的东西、系统的回调函数。具体看有没有需要。

4、导出函数别名怎么写？
可以在.def文件里对函数名写一个别名。

例如：

EXPORTS

cswuygTest（别名） = _showfun@4(要导出的函数)

 

或者：

    #pragma comment(linker, "/export:[别名] =[NameMangling后的名称]")

这样做就可以随便修改别名了，不会出现找不到符号的错误。

5、用不用*.def文件？
如果采用VC默认的调用约定，可以不用*.def文件，如果要采用__stdcall调用约定，又不想函数名被修饰，那就采用*.def文件吧,另一种在代码里写的重命名的方式不够方便。

6、什么情况下（不）需要考虑函数重命名的问题？
1）、隐式调用（通过lib）

如果dll的制造者跟dll的使用者采用同样的语言、同样编程环境，那么就不需要考虑函数重命名。使用者在调用函数的时候，通过Name Mangling后的函数名能在lib里找到该函数。

如果dll的制造者跟dll使用不同的语言、或者不同的编译器，那就需要考虑重命名了。

2）、显示调用（通过GetProcessAddress）

       这绝对是必须考虑函数重命名的。

7、总结
    总的来说，在编写DLL的时候，写个头文件，头文件里声明函数的NameMingling方式、调用约定（主要是为了隐式调用）。再写个*.def文件把函数重命名了（主要是为了显式调用）。提供*.DLL\*.lib\*.h给dll的使用者，这样无论是隐式的调用，还是显式的调用，都可以方便的进行。



8.补充：

调用协议常用场合
__stdcall：Windows API默认的函数调用协议。
__cdecl：C/C++默认的函数调用协议。
__fastcall：适用于对性能要求较高的场合。
函数参数入栈方式
__stdcall：函数参数由右向左入栈。
__cdecl：函数参数由右向左入栈。
__fastcall：从左开始不大于4字节的参数放入CPU的ECX和EDX寄存器，其余参数从右向左入栈。
问题一：__fastcall在寄存器中放入不大于4字节的参数，故性能较高，适用于需要高性能的场合。
栈内数据清除方式
__stdcall：函数调用结束后由被调用函数清除栈内数据。
__cdecl：函数调用结束后由函数调用者清除栈内数据。
__fastcall：函数调用结束后由被调用函数清除栈内数据。
问题一：不同编译器设定的栈结构不尽相同，跨开发平台时由函数调用者清除栈内数据不可行。
问题二：某些函数的参数是可变的，如printf函数，这样的函数只能由函数调用者清除栈内数据。
问题三：由调用者清除栈内数据时，每次调用都包含清除栈内数据的代码，故可执行文件较大。
C语言编译器函数名称修饰规则
__stdcall：编译后，函数名被修饰为“_functionname@number”。
__cdecl：编译后，函数名被修饰为“_functionname”。
__fastcall：编译后，函数名给修饰为“@functionname@nmuber”。
注：“functionname”为函数名，“number”为参数字节数。
注：函数实现和函数定义时如果使用了不同的函数调用协议，则无法实现函数调用。
C++语言编译器函数名称修饰规则
__stdcall：编译后，函数名被修饰为“?functionname@@YG******@Z”。
__cdecl：编译后，函数名被修饰为“?functionname@@YA******@Z”。
__fastcall：编译后，函数名被修饰为“?functionname@@YI******@Z”。
注：“******”为函数返回值类型和参数类型表。
注：函数实现和函数定义时如果使用了不同的函数调用协议，则无法实现函数调用。
C语言和C++语言间如果不进行特殊处理，也无法实现函数的互相调用。


### 链接动态库

---------------------------------------------------------------------------------
